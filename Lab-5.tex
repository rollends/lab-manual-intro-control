\chapter{Lead and Lag Compensator Design}\label{Lab:5}
Now that you have 
This time, you are designing an unmanned aerial vehicle that is dropped into the atmosphere and performs powered glides along predefined paths over the surface.
%
\begin{center}
  %\centering
  \input{Lab_4_UAV_PF.pdf_tex}%
  %\caption{Unmanned Aerial Vehicle (UAV) moving with respect to some line.}
  %\label{fig:lab4:uav}
\end{center}
%
The purpose is to do surveillance\footnote{Don't worry. The CEO of VenX, Lone Dusk, has assured you that the FBI are not using your technology for surveilling citizens in protests. Should you trust him? Probably not. But in this lab, you live in a utopia where people and the government are very honourable.} of the planet's surface to map out the landscape.

The controller you design controls the turning rate (\SI{}{rad/s}) and the output you measure is the distance to the straight line path \(y(t)\) (\SI{}{m}).
In practice the transfer function from this input to \(y(t)\) is highly nonlinear, but the senior engineers have designed an inner loop controller that makes the plant \(P(s)\) look like
\[
  P(s) = \frac{1}{s^2}.
\]
Take \texttt{ECE 486}\footnote{In the robotics course you will learn to just cancel the nonlinearities out.} if you are interested in how to do this.

 --- a very similar system to the one you created in Lab~\ref{Lab:4}.
In this lab, you do not have access to the transfer function for \(P(s)\) directly.
Instead you will acquire the frequency response (Bode plot) empirically via MATLAB and perform your design against this.
You will also verify closed loop stability using an empirically acquired Nyquist plot.
This is quite common in practice for plants that are difficult to model or for plants where it is hard to perform parameter estimation due to the large number of parameters and sensitivity.

\section{Objectives}\label{Lab:4:Objectives}
This goals of this lab are to
\begin{enumerate}[label=(\arabic*)]
  \item{
    \textbf{Practice} the Lead and Lag Design Procedures.
  }
  \item{
    \textbf{Learn} how delays in the loop can affect stability.
  }
  \item{
    \textbf{Learn} about the robustness specification imposed on the Nyquist plot of \(L(s)\) that determines the maximum delay \(L(s)\) can afford before losing stability.
  }
\end{enumerate}
The deliverable dependency graph is
\begin{center}
\begin{tikzpicture}[x=1em, y=1em]
  \node[deliverable] (D1) {Deliverable\\\ref{del:lab4:p1:1}};
  \node[deliverable, below = 2 of D1] (D2) {Deliverable\\\ref{del:lab4:p2:1}--\ref{del:lab4:p2:3}};
  \node[deliverable, below = 2 of D2] (D3) {Deliverable\\\ref{del:lab4:p3:1}--\ref{del:lab4:p3:3}};
  \node[deliverable, right = 2 of D3] (Q1) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q1}--\ref{lab4:report:q2}};
  \node[deliverable, below = 2 of Q1] (Q4) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q4}};
  \node[deliverable, right = 2 of Q4] (Q5) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q5}};
  \node[deliverable, at = {(Q5|-D1)}] (Q3) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q3}};
  \node[deliverable, right = 2 of Q5] (Q6) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q6}};
  \node[deliverable, left = 2 of D3] (Q7) {Deliverable\\\ref{lab4:report}~\ref{lab4:report:q7}};

  \draw[signal, arrow] (D1.south) -- (D2.north);
  \draw[signal, arrow] (D2.south) -- (D3.north);
  \draw[signal, arrow] (D3.east) -- (Q1.west);
  \draw[signal, arrow] (D3.south) |- (Q4.west);
  \draw[signal, arrow] (Q4.east) -- (Q5.west);
  \draw[signal, arrow] (Q3.south) -- (Q5.north);
  \draw[signal, arrow] (Q5.east) -- (Q6.west);
  \draw[signal, arrow] (D3.west) -- (Q7.east);

\end{tikzpicture}
\end{center}

\section{Experimental Procedure}\label{Lab:4:Experiment}
This lab is split into four parts.
In Part I you will simulate 
In Part II you will analyze how the integral term affects the performance of your system.
Finally in Part III you make an incremental change to your PID controller to improve your system's performance qualitatively.
The plant for this lab will be
\[
  P(s) = \frac{1}{s^2}.
\]

\subsection{Preamble: Delays}
A ``perfect'' delay by time \(\tau\) from an input signal \(u(t)\) to an output signal \(y(t)\) is determined by the static equation
\[
  y(t) = u(t - \tau).
\]
Verify for yourself that this definition ensures the value of the output \(y\) at some time \(t\) is given by the value of the input signal \(u\) at a time \(\tau\) units prior.
Take the Laplace transform of both sides\footnote{and suppose the integrals converge} to find that
\[
  Y(s) = e^{-\tau s} U(s).
\]
It is in this sense that one can view \(e^{-\tau s}\) as the transfer function of the delay operator.
This is significant as it gives a frequency-domain version of the time delay allowing us to translate a time-domain specification to a frequency-domain specification.
%
Suppose a loop transfer function \(L(s)\) satisfies the Nyquist criterion.
Equivalently, imagine that the closed loop system
%
\begin{center}
  \begin{tikzpicture}[x=1in, y=1in]
    \node [draw, smooth_block] (Plant) {\(L(s)\)};
    \node [draw, smooth_block, below = 0.25 of Plant] (Delay) {\(1\)};
    \node [draw, smooth_sum, left = 0.50 of Plant] (Sum1) {};
    \node [right = 0.50 of Plant] (after_plant) {};
    \node [right = 0.50 of after_plant] (y) {};
    \node [left = 0.50 of Sum1] (r) {};

    \draw [arrow, smooth_path]
      (Plant.east) -- (after_plant.base) -- (y.base) node [below right] {\(y\)};
    \draw [arrow, smooth_path]
      (Plant.east)
      --
      (after_plant.base)
      |-
      (Delay.east);
    \draw [arrow, smooth_path]
      (Delay.west)
      -|
      (Sum1.south)
      node [below right] {\(-\)};
    \draw [arrow, smooth_path]
      (Sum1.east)
      --
      (Plant.west);
    \draw [arrow, smooth_path]
      (r.base)
      node [below left] {\(r\)}
      --
      (Sum1.west);
  \end{tikzpicture}
\end{center}
%
is stable.
We would like to meet the specification that:
\begin{quote}
  The closed loop system remains stable under a delay of \(\tau\) seconds.
\end{quote}
In terms of transfer functions we can imagine asking that the closed loop system 
%
\begin{center}
  \begin{tikzpicture}[x=1in, y=1in]
    \node [draw, smooth_block] (Plant) {\(L(s)\)};
    \node [draw, smooth_block, below = 0.25 of Plant] (Delay) {\(e^{-\tau s}\)};
    \node [draw, smooth_sum, left = 0.50 of Plant] (Sum1) {};
    \node [right = 0.50 of Plant] (after_plant) {};
    \node [right = 0.50 of after_plant] (y) {};
    \node [left = 0.50 of Sum1] (r) {};

    \draw [arrow, smooth_path]
      (Plant.east) -- (after_plant.base) -- (y.base) node [below right] {\(y\)};
    \draw [arrow, smooth_path]
      (Plant.east)
      --
      (after_plant.base)
      |-
      (Delay.east);
    \draw [arrow, smooth_path]
      (Delay.west)
      -|
      (Sum1.south)
      node [below right] {\(-\)};
    \draw [arrow, smooth_path]
      (Sum1.east)
      --
      (Plant.west);
    \draw [arrow, smooth_path]
      (r.base)
      node [below left] {\(r\)}
      --
      (Sum1.west);
  \end{tikzpicture}
\end{center}
%
If you compare the Nyquist plot of \(L(s)\) with the Nyquist plot of \(e^{-\tau s} L(s)\) you will observe that they look very similar;
in fact, a number of points of the latter Nyquist plot look like a rotated version of the former Nyquist plot.
This notion (if put formally) allows us to translate the earlier delay specification into the following phase margin specification: 
\begin{quote}
  The loop transfer function \(L(s)\) has a phase margin strictly greater than \(\tau \omega_{\mathrm{gc}}\) where \(\omega_{\mathrm{gc}}\) is the gain crossover frequency in \SI{}{\radian}.
\end{quote}
This is the primary specification you will meet.
Note that this translation of specification only makes sense when \(L(s)\) is already stable.
Also note that changes in the phase margin could change the gain crossover and thereby change what delays you can afford.

\subsection{Part I: Delays and Stability}
Consider the simple proportional feedback loop
%
\begin{center}
  \begin{tikzpicture}[x=1in, y=1in]

    \node [draw, smooth_block] (Plant) {\(P(s)\)};
    \node [draw, smooth_block, left = 0.50 of Plant] (Gain1) {\(K\)};
    \node [draw, smooth_sum, left = 0.50 of Gain1] (Sum1) {};
    \node [right = 0.50 of Plant] (after_plant) {};
    \node [right = 0.50 of after_plant] (y) {};
    \node [left = 0.50 of Sum1] (r) {};

    \node [smooth_annotate, below = 0 of Gain1] {Controller};
    \node [smooth_annotate, below = 0 of Plant] {Plant};

    \draw [arrow, smooth_path]
      (Plant.east) -- (after_plant.base) -- (y.base) node [below right] {\(y\)};
    \draw [arrow, smooth_path]
      (Plant.east)
      --
      (after_plant.base)
      --
      +(0, -0.75)
      -|
      (Sum1.south)
      node [below right] {\(-\)};
    \draw [arrow, smooth_path]
      (Sum1.east)
      node [above right] {\(e\)}
      --
      (Gain1.west);
    \draw [arrow, smooth_path]
      (Gain1.east)
      --
      (Plant.west);
    \draw [arrow, smooth_path]
      (r.base)
      node [below left] {\(r\)}
      --
      (Sum1.west);
  \end{tikzpicture}
\end{center}
where \(P(s)\) is the dynamics of line-following drone.
Your first task is to
%
\begin{deliverable}[label={del:lab5:p1:1}]
  \textbf{Choose} a loop gain \(K\) so that the steady-state step tracking error is less than or equal to \(1\%.\)
\end{deliverable}
%
You will then acquire a Nyquist plot to verify stability of the closed loop system when there are no delays as well as acquire a Nyquist plot to demonstrate instability when the delay is introduced.
%
\begin{deliverable}[label={del:lab5:p1:2}]
  \textbf{Acquire} two Nyquist plots (using the Model Linearizer app) so that
  \begin{itemize}
    \item{one demonstrates the stability of the gain-compensated closed loop system when there is no delay and}
    \item{the other demonstrates the instability of the gain-compensated closed loop system with a delay.}
  \end{itemize}
\end{deliverable}
%
To complete these tasks, follow the next procedure.
%
\begin{procedure}[label={proc:lab4:kpkd}]
  In this procedure you will determine a gain \(K\) and acquire the required Nyquist plots.
  You will also get a chance to simulate the system.
  \begin{enumerate}[label={(\arabic*)}]
    \item{%
      Assume the plant \(P(s)\) has a DC gain \(1.\)
      The transfer function from \(r(t)\) to \(e(t)\) is
      \[
        \frac{1}{1 + K P(s)}.
      \]
      \textbf{Choose} a gain \(K\) so that the DC gain of this transfer function is less than \(0.01.\)
      This assures a steady-state tracking error of less than \(1\%.\)
    }
    \item{%
      \textbf{Change} the variable \texttt{K} \emph{in the MATLAB script} ``procedure\_5\_1.m'' to match your chosen gain.
      \textbf{Run} the script.
    }
    \item{%
      \textbf{Open} the ``Lab\_5\_Model\_System.slx'' Simulink model and \textbf{ensure} that the switch is pointed towards the path without the ``Delay.''
    }
    \item{%
      \textbf{Open} the Model Linearizer App and \textbf{acquire} a Nyquist plot.
      This produces part of Deliverable~\ref{del:lab5:p1:2}.
      Assuming \(P(s)\) has no unstable poles, \textbf{verify} that you have closed loop stability.
    }
    \item{%
      \textbf{Open} the ``Lab\_5\_Model\_System.slx'' Simulink model and \textbf{ensure} that the switch is pointed towards the path \textbf{with} the ``Delay.''
    }
    \item{%
      \textbf{Open} the Model Linearizer App and \textbf{acquire} a Nyquist plot.
      This completes Deliverable~\ref{del:lab5:p1:2}.
      Assuming \(P(s)\) has no unstable poles, \textbf{verify} that you do not have closed loop stability.
    }
  \end{enumerate}
\end{procedure}

\subsection{Part II: Introducing an Integral Component}
We would like to eliminate the observed constant steady-state error.
How do we do this?
First we must determine why this error appears.
It is fair to ask:
``If our plant already has an integrator, how is it that there is constant steady-state error?''
In this simulation there is a constant \emph{input} disturbance similar to the \(d(t)\) of Lab~\ref{Lab:3}.
As you verified in Lab~\ref{Lab:3}, even an integrator in the plant cannot perfectly reject this input disturbance and can only attenuate it under proportional error feedback.
If we introduce a pole at the origin, i.e. an integrator, in the controller we can perfectly reject this error.
Unfortunately, there is a constraint on how large the integrator term can be.
Your deliverable for this part is to simply choose an integrator gain.
%
\begin{deliverable}[label={del:lab4:p2:1}]
  \textbf{Choose} and \textbf{record} a gain \(K_i > 0\) that perfectly rejects the step disturbance while ensuring closed loop stability.
\end{deliverable}
%
To do this we will make use of the root locus method.
As such, you are required to also produce a relevant root locus.
%
\begin{deliverable}[label={del:lab4:p2:2}]
  \textbf{Acquire} the root locus generated by the ``part\_2.m'' MATLAB script.
  \textbf{Place} a cursor on a point where the system is unstable so that you recognize how large \(K_i\) is allowed to be.
  \textbf{Save} the figure.
\end{deliverable}
%
Finally you will acquire the complete system response.
%
\begin{deliverable}[label={del:lab4:p2:3}]
  \textbf{Acquire} Figure 2 by running the ``visualize\_uav.m'' MATLAB script and \textbf{save} it.
\end{deliverable}
%
Your complete PID control system looks like
%
\begin{center}
  \begin{tikzpicture}[x=1in, y=1in]

    \node [draw, smooth_block] (Plant) {%
      \(\frac{1}{s^2}\)%
    };
    \node [draw, smooth_sum, left = 0.25 of Plant] (Sum2) {};
    \node [draw, smooth_block, left = 0.25 of Sum2] (Gain1) {%
      \(K_p + K_d s\)%
    };
    \node [draw, smooth_block, above = 0.25 of Gain1] (Gain2) {%
      \(\frac{K_i}{s}\)%
    };
    \node [draw, smooth_sum, left = 0.50 of Gain1] (Sum1) {};
    \node [right = 0.75 of Plant] (after_plant) {};
    \node [right = 0.75 of after_plant] (y) {};
    \node [left = 0.75 of Sum1] (r) {};

    \draw [arrow, smooth_path]
      (Plant.east) -- (after_plant.base) -- (y.base) node [below right] {\(y\)};
    \draw [arrow, smooth_path]
      (Plant.east)
      --
      (after_plant.base)
      --
      +(0, -0.75)
      -|
      (Sum1.south)
      node [below right] {\(-\)};
    \draw [arrow, smooth_path]
      (Sum1.east)
      --
      (Gain1.west);
    \draw [arrow, smooth_path]
      (Sum1.east)
      --
      +(0.25, 0)
      |-
      (Gain2.west);
    \draw [arrow, smooth_path]
      (Gain1.east)
      --
      (Sum2.west);
    \draw [arrow, smooth_path]
      (Gain2.east)
      -|
      (Sum2.north);
    \draw [arrow, smooth_path]
      (Sum2.east)
      --
      (Plant.west)
      node [below left] {\(u\)};
    \draw [arrow, smooth_path]
      (r.base)
      node [below left] {\(r\)}
      --
      (Sum1.west);
  \end{tikzpicture}
\end{center}
%
where you have determined \(K_p\) and \(K_d\) already.
The closed loop poles of this system\footnote{Notice what I do not say. I am \textbf{not} saying the closed loop zeros or the DC gain are the same.} are the same as the poles of the closed loop system
%
\begin{center}
  \begin{tikzpicture}[x=1in, y=1in]

    \node [draw, smooth_block] (Plant) {%
      \(\frac{1}{s(s^2 + K_d s + K_p)}\)%
    };
    \node [draw, smooth_block, left = 0.50 of Plant] (Gain1) {%
      \(K_i\)%
    };
    \node [draw, smooth_sum, left = 0.50 of Gain1] (Sum1) {};
    \node [right = 0.50 of Plant] (after_plant) {};
    \node [right = 0.50 of after_plant] (y) {};
    \node [left = 0.50 of Sum1] (r) {};

    \draw [arrow, smooth_path]
      (Plant.east) -- (after_plant.base) -- (y.base);
    \draw [arrow, smooth_path]
      (Plant.east)
      --
      (after_plant.base)
      --
      +(0, -0.50)
      -|
      (Sum1.south)
      node [below right] {\(-\)};
    \draw [arrow, smooth_path]
      (Sum1.east)
      --
      (Gain1.west);
    \draw [arrow, smooth_path]
      (Gain1.east)
      --
      (Plant.west);
    \draw [arrow, smooth_path]
      (r.base)
      --
      (Sum1.west);
  \end{tikzpicture}
\end{center}
It follows that if we plot the (positive gain) root locus of \(\frac{1}{s(s^2 + K_d s + K_p)}\) and choose a gain so that the poles of this system meet our desired specifications, we can use this very same gain as \(K_i\) in our closed loop system to produce the same poles that meet the same specifications.
The next procedure guides you through these steps.
%
\begin{procedure}[label={proc:lab4:ki}]
  In this procedure you will produce a root locus and make an initial choice for the gain \(K_i.\)
  \begin{enumerate}[label={(\arabic*)}]
    \item{%
      \textbf{Modify} the ``part\_2.m`` MATLAB script so that the variables \texttt{Kp} and \texttt{Kd} match your chosen gains from Part I.
      \textbf{Run} the ``part\_2.m'' MATLAB script.
      \textbf{Inspect} Figure 3.
    }
    \item{%
      \textbf{Observe} that if \(K_i\) is too large, the system will be rendered unstable. \textbf{Place a cursor} on one such point on the root locus.
      \textbf{Save} this Figure for Deliverable~\ref{del:lab4:p2:2}.
    }
    \item{%
      \textbf{Take note} of the gain depicted by your cursor in the previous step.
      If \(K_i\) takes on a value larger than this gain, your system may be rendered unstable!
    }
    \item{%
      \textbf{Pick any} value of \(K_i\) between \(0\) and the maximum gain defined by the previous step.
    }
    \item{%
      \textbf{Read} the cursor to find out what the gain value is.
      \textbf{Record} this gain value as the value you choose for \(K_i\) producing Deliverable~\ref{del:lab4:p2:1}.
    }
  \end{enumerate}
\end{procedure}
%
Now that you have chosen \(K_i\) you are ready to test out whether it worked.
There is no deliverable for the next procedure as it is only a verification that the previous procedures went smoothly.
%
\begin{procedure}[label={proc:lab4:verify}]
  You will now verify your choice of \(K_i.\)
  \begin{enumerate}[label={(\arabic*)}]
    \item{%
      \textbf{Set} the integrator gain with your chosen value of \(K_i.\)
    }
    \item{%
      \textbf{Run} the ``visualize\_uav.m'' MATLAB script and \textbf{inspect} Figures 1 and 2.
      \textbf{Observe} that the UAV continues to track the path but now does so without steady-state error.
      \textbf{Save} Figure 2 for Deliverable~\ref{del:lab4:p2:3}.
    }
  \end{enumerate}
\end{procedure}

\subsection{Part III: Tune your Controller}
Now that we have eliminated the steady-state error, you may observe more extreme oscillations or a large overshoot.
In this part, you will make an attempt to improve the performance of your controller.
Your deliverable for this section is
%
\begin{deliverable}[label={del:lab4:p3:1}]
  \textbf{Acquire} the root locus plots generated by the ``part\_3.m'' MATLAB script with your PID gains determined at the end of Part II.
  \textbf{Save} the figures.
\end{deliverable}
%
and you will use this information, alongside your other intuitions, to guide another choice of gains.
%
\begin{deliverable}[label={del:lab4:p3:2}]
  \textbf{Determine} a new set of gains \(K_p,\) \(K_i\) and \(K_d\) that in some way improve the performance of your UAV.
  This may be in reduced overshoot, or reduced settling time, for example.
  You may consider any characteristic you consider undesireable.
\end{deliverable}
%
Finally, you will acquire and save Figure 2 generated by ``visualize\_uav.m'' to prove you have achieved perfect tracking.
%
\begin{deliverable}[label={del:lab4:p3:3}]
  \textbf{Acquire} Figure 2 by running the ``visualize\_uav.m'' MATLAB script and \textbf{save} it to depict the improved performance.
  If there is no improvement, \textbf{acquire} atleast three simulations (of three different gain choices) producing Figure 2 and \textbf{save all of them}. \textbf{Record} the changes you made.
\end{deliverable}
%
\begin{procedure}[label={proc:lab4:tune}]
  There is no explicit procedure to tune your controller but this high-level series of steps can help you make your initial changes.
  \begin{enumerate}[label={(\arabic*)}]
    \item{%
      \textbf{Modify} the ``part\_3.m`` MATLAB script so that the variables \texttt{Kp}, \texttt{Kd} and \texttt{Ki} match the gains you chose in Part II.
      \textbf{Run} the ``part\_3.m'' MATLAB script.
      \textbf{Save} the figures (4, 5, 6) for Deliverable~\ref{del:lab4:p3:1}.
    }
    \item{%
      \textbf{Inspect} the root locus plots generated.
      Each root locus depicts your current closed loop poles with filled black circles.
      You can therefore see how changing any gain would change the location of the closed loop poles and thereby change the behaviour of your final closed loop system.
      The settling time of your system is determined primarily by the real part of the pole closest to the imaginary axis.
      The overshoot is determined primarily by the largest angle of the poles relative to the negative real axis.
      You can also see exactly what a pole will contribute to your system by clicking on the root locus to produce a cursor.
    }
    \item{%
      Guided by the location of the poles currently and the root locus plots produced, \textbf{decide} on a gain to change to improve atleast one characteristic of your system.
      \textbf{Make} the change to that gain. 
    }
    \item{%
      \textbf{Acquire} Figure 2 by running the ``visualize\_uav.m'' MATLAB script and \textbf{verify} that you did improve the characteristic you set out to improve.
      If successful, \textbf{save} it for Deliverable~\ref{del:lab4:p3:3} and \textbf{record} your gain choices for Deliverable~\ref{del:lab4:p3:2}.
      If not successful explore the range of parameters available to see what changes you can make happen.
      \emph{If no improvement is possible, save three simulations (Figure 2, in particular) of \textbf{atleast three distinct choices you trialed}. \textbf{Record} what those choices were.}
    }
  \end{enumerate}
\end{procedure}

\section{Report Deliverable}\label{Lab:4:Report}
Another lab nearly complete!
As usual, you are expected to submit a report demonstrating that you completed the lab and that you understand the tasks performed.
In addition to including
\begin{itemize}
  \item{Deliverable~\ref{del:lab4:p1:1},}
  \item{Deliverable~\ref{del:lab4:p2:1},}
  \item{Deliverable~\ref{del:lab4:p2:2},}
  \item{Deliverable~\ref{del:lab4:p2:3},}
  \item{Deliverable~\ref{del:lab4:p3:1},}
  \item{Deliverable~\ref{del:lab4:p3:2} and}
  \item{Deliverable~\ref{del:lab4:p3:3}}
\end{itemize}
in your report, you are required to answer the questions of the following deliverable.
Make sure to leverage your other deliverables in your answers!
\begin{deliverable}[label={lab4:report}]
  \begin{enumerate}[label={(\arabic*)}]
    \item{%
      Like in Lab~\ref{Lab:3}, the primary output was a (relative) position \(y(t).\)
      Unlike Lab~\ref{Lab:3}, we do not observe the velocity explicitly but, instead, use the differentiator in the PID controller to estimate velocity (derivative of the relative position is velocity) and apply that in closed loop feedback.
      Unfortunately, the explicit use of a differentiator in parallel to the proportional error feedback introduced zeros in the final transfer function \(G(s)\) from \(r(t)\) to \(y(t).\)
      In particular
      \[
        G(s) = K_d \frac{s^2 + \frac{K_p}{K_d} s + \frac{K_i}{K_d}}{s^3 + K_d s^2 + K_p s + K_i}.
      \]
      For your final choice of \(K_p,\) \(K_i\) and \(K_d,\) \textbf{determine} where the zeros of \(G(s)\) are located.
      \label{lab5:report:q1}
    }
  \end{enumerate}
\end{deliverable}

\subsection{Grading Scheme}
The grading scheme is shown in Table~\ref{tab:lab4:grading}. The breakdown of
your grade is shown per deliverable except in the case of the lab
questions where it is shown per question.
%
\begin{table}
\centering
\begin{tabular}{c|l|c}
        & Deliverable           & Marks  \\ \hline
        & \ref{del:lab4:p1:1}         & 4       \\ \hline
        & \ref{del:lab4:p2:1}         & 4       \\ \hline
        & \ref{del:lab4:p2:2}         & 4      \\ \hline
        & \ref{del:lab4:p2:3}         & 4      \\ \hline
        & \ref{del:lab4:p3:1}         & 6       \\ \hline
        & \ref{del:lab4:p3:2}         & 4       \\ \hline
        & \ref{del:lab4:p3:3}         & 4       \\ \hhline{=|=|=}
Lab Subtotal&                       & 30      \\ \hhline{=|=|=}
        & \ref{lab5:report}~\ref{lab4:report:q1}  & 2       \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q2}  & 2       \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q3}  & 4       \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q4}  & 6       \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q5}  & 2      \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q6}  & 2      \\ \hline
        & \ref{lab5:report}~\ref{lab4:report:q7}  & 2      \\ \hhline{=|=|=}
Report Subtotal&  & 20 \\ \hhline{=|=|=}
  Total &                       & 50
\end{tabular}
\caption[Grading Scheme for Lab 5]{Grading scheme for Lab 5.}
\label{tab:lab5:grading}
\end{table}
%
